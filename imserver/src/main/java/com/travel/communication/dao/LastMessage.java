package com.travel.communication.dao;

import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "LAST_MESSAGE".
 */
public class LastMessage {

    private Long id;
    private String senderId;
    private String receiverId;
    private Integer unReadNumber;
    private Long messageId;
    private Boolean isVisible;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient LastMessageDao myDao;

    private UserData receiver;
    private String receiver__resolvedKey;

    private UserData sender;
    private String sender__resolvedKey;

    private Message message;
    private Long message__resolvedKey;


    public LastMessage() {
    }

    public LastMessage(Long id) {
        this.id = id;
    }

    public LastMessage(Long id, String senderId, String receiverId, Integer unReadNumber, Long messageId, Boolean isVisible) {
        this.id = id;
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.unReadNumber = unReadNumber;
        this.messageId = messageId;
        this.isVisible = isVisible;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getLastMessageDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getSenderId() {
        return senderId;
    }

    public void setSenderId(String senderId) {
        this.senderId = senderId;
    }

    public String getReceiverId() {
        return receiverId;
    }

    public void setReceiverId(String receiverId) {
        this.receiverId = receiverId;
    }

    public Integer getUnReadNumber() {
        return unReadNumber;
    }

    public void setUnReadNumber(Integer unReadNumber) {
        this.unReadNumber = unReadNumber;
    }

    public Long getMessageId() {
        return messageId;
    }

    public void setMessageId(Long messageId) {
        this.messageId = messageId;
    }

    public Boolean getIsVisible() {
        return isVisible;
    }

    public void setIsVisible(Boolean isVisible) {
        this.isVisible = isVisible;
    }

    /** To-one relationship, resolved on first access. */
    public UserData getReceiver() {
        String __key = this.receiverId;
        if (receiver__resolvedKey == null || receiver__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDataDao targetDao = daoSession.getUserDataDao();
            UserData receiverNew = targetDao.load(__key);
            synchronized (this) {
                receiver = receiverNew;
            	receiver__resolvedKey = __key;
            }
        }
        return receiver;
    }

    public void setReceiver(UserData receiver) {
        synchronized (this) {
            this.receiver = receiver;
            receiverId = receiver == null ? null : receiver.getId();
            receiver__resolvedKey = receiverId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public UserData getSender() {
        String __key = this.senderId;
        if (sender__resolvedKey == null || sender__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDataDao targetDao = daoSession.getUserDataDao();
            UserData senderNew = targetDao.load(__key);
            synchronized (this) {
                sender = senderNew;
            	sender__resolvedKey = __key;
            }
        }
        return sender;
    }

    public void setSender(UserData sender) {
        synchronized (this) {
            this.sender = sender;
            senderId = sender == null ? null : sender.getId();
            sender__resolvedKey = senderId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Message getMessage() {
        Long __key = this.messageId;
        if (message__resolvedKey == null || !message__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MessageDao targetDao = daoSession.getMessageDao();
            Message messageNew = targetDao.load(__key);
            synchronized (this) {
                message = messageNew;
            	message__resolvedKey = __key;
            }
        }
        return message;
    }

    public void setMessage(Message message) {
        synchronized (this) {
            this.message = message;
            messageId = message == null ? null : message.getId();
            message__resolvedKey = messageId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
